#!/usr/bin/env python

import re
import ConfigParser
import os
import subprocess
import logging
import time

import sys
sys.path.append('./lib')
import github
import gitlab

def readConfig(configFile='~/.gitlabsyncrc'):
    config = ConfigParser.ConfigParser()
    config.read(configFile)

    # Read in core options
    conf = {}
    conf['githuborg'] = config.get('global','gitHubOrgName')
    conf['gitlaborg'] = config.get('global','gitLabNSpace')
    conf['gitlabRepoBase'] = config.get('global','gitLabRepos')
    conf['GHtoken'] = config.get('global','gitHubToken')
    conf['GLtoken'] = config.get('global','gitLabToken')
    conf['GLurl'] = config.get('global','gitLabUrl')
    conf['logDir'] = config.get('global','logDir')

    return conf

def getRepoConfig(repo, configFile='~/.gitlabsyncrc'):
    config = ConfigParser.ConfigParser()
    config.read(configFile)

    # Return value, with defaults:
    conf = {'gitlaborg': config.get('global','gitLabNSpace'),
            'gitlabRepo': repo}

    if config.has_section(repo):
        if config.has_option(repo,'gitLabNSpace'):
            conf['gitlaborg'] = config.get(repo,'gitLabNSpace')
        if config.has_option(repo,'gitLabRepoName'):
            conf['gitlabRepo'] = config.get(repo,'gitLabRepoName')
    return conf

def getRepoRemoteName(repo_path, remote_url):
    """Return the repository's remote name.  This only returns the first
    remote name that matches remote_url (if there are more than one).  If
    the remote name doesn't exist, then it creates a 'github' remote in the
    repository at repo_path (repo_path must exist)."""

    # Default return is None
    remote_name = None

    # Check if repo_path exists
    if os.path.isdir(repo_path):
        # Check if remote is available
        logging.debug("Checking for git remote in repository: "+repo_path)
        pr = subprocess.Popen(['git', 'remote', '-v'],
                              cwd=repo_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              shell=False)
        (out, err) = pr.communicate()
        if err:
            logging.warning("git remote -v\n"+err)

        match = re.search('(\S+)\s'+str(remote_url)+'\s+\(fetch\)', out)
        if match:
            remote_name = match.group(1)
        else:
            # Remote doesn't exist, setup the remote
            remote_name = 'github'
            logging.info("Adding remote to repository: "+repo_path)
            pr = subprocess.Popen(['git', 'remote', 'add', '--mirror=fetch', remote_name, remote_url],
                                  cwd=repo_path,
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE,
                                  shell=False)
            (out, err) = pr.communicate()
            if err:
                logging.warning("git remote add --mirror=fetch "+remote_name+" "+ghRepo.ssh_url+"\n"+err)
    return remote_name

def updateRepo(source_url, target_path):
    remote_name = getRepoRemoteName(target_path, source_url)

    if remote_name:
        logging.info("Updating remote repository: "+source_url)
        pr = subprocess.Popen(['git', 'remote', '-v', 'update', '-p', remote_name],
                              cwd=target_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              shell=False)
        (out, err) = pr.communicate()
        if out:
            logging.info("git remote update "+remote_name+"\n"+out)
        if err:
            logging.warning("git remote update "+remote_name+"\n"+err)

# Main program
def main():
    myConfigFile = os.getcwd()+'/gh_sync.conf'
    config = readConfig(myConfigFile)

    logging.basicConfig(filename=config['logDir']+'/gh_sync.log',
                        format='%(asctime)s [%(levelname)s] %(message)s',
                        datefmt='%Y-%m-%dT%H:%M:%S',
                        level=logging.INFO)
    logging.info('*' * 72)
    logging.info('Starting gitHub sync')

    # Connect to gitHub
    gh = github.Github(token=config['GHtoken'])

    # Connect to gitlab
    gl = gitlab.Gitlab(config['GLurl'], config['GLtoken'])

    for ghRepo in gh.getRepos(name=config['githuborg'], type="orgs"):
        logging.info('Starting sync of '+ghRepo.name)

        repoConfig = getRepoConfig(ghRepo.name, myConfigFile)

        glProject = gl.findProject(ghRepo.name, repoConfig['gitlaborg'])
        if glProject.id == -1:
            # No gitlab project found
            logging.info("Creating new repository: "+repoConfig['gitlaborg']+'/'+ghRepo.name)
            glProject = gl.createProject(ghRepo.name, repoConfig['gitlaborg'],
                                    wiki_enabled=ghRepo.has_wiki)
            # Give time for the repository directory to be created
            time.sleep(5)

        # Sync the project repository
        updateRepo(ghRepo.ssh_url, os.path.join(config['gitlabRepoBase'],glProject.path))

        # Now sync the wiki repo
        if ghRepo.has_wiki:
            # Verify that the wiki path exists
            gl_wiki_path = os.path.join(config['gitlabRepoBase'],glProject.wiki_path)
            if not os.path.isdir(gl_wiki_path):
                # Simply touch the wiki page to create the wiki repository
                gl.touchProjectWiki(glProject)
                # Give time for the repository directory to be created
                time.sleep(5)
            updateRepo(ghRepo.wiki_url, os.path.join(config['gitlabRepoBase'],glProject.wiki_path))

    logging.info('Ending gitHub sync')

if __name__ == "__main__":
    main()
